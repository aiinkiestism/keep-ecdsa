:toc: macro

= RFC 2: tBTC liquidation recovery functionality

:icons: font
:numbered:
toc::[]

== Background

The Keep ECDSA client is a generic client for ECDSA keeps, which are on-chain
smart contract representations of a signing group that can provide on-demand
key generation and signature services for a consumer application (represented
by another smart contract). These applications occasionally require
application-specific functionality that is best handled by the ECDSA client.
tBTC is one such application that requires certain functionality specific to
it implemented in the ECDSA client. RFC 1 describes an approach for handling
certain, but not all, tBTC-specific functionality.

In the Ethereum deployment of the tBTC system, the ECDSA keeps secure their
correct operation by putting up collateral in the form of ETH on Ethereum. In
cases where the collateral becomes insufficient for the tBTC system to
guarantee its invariants (an amount that is controllable in the tBTC contracts),
the tBTC system is authorized to _seize_ this collateral, and begin an auction
process to bring itself back into balance.

In these scenarios, the ECDSA keep signers are in control of BTC that can be
split among their owners. This RFC seeks to outline a tBTC-specific
functionality that would allow the clients in the signer group to
automatically recover the BTC to designated addresses on the Bitcoin chain.

=== Current Functionality

ECDSA clients currently monitor the chain for notifications that a Keep has
closed abnormally, in particular in the function
https://github.com/keep-network/keep-ecdsa/blob/b916eaa491b886fb6c7cde2706d225b5b85ac2a2/pkg/client/client.go#L778[`monitorKeepTerminatedEvent`].
For tBTC, a termination indicates that the keep backing a deposit has been
closed without a successful redemption, meaning that the keep still holds
BTC. Upon receiving a termination event, the client waits for a set number of
block confirmations to occur in order to be sure the event will not be
reorged away, then archives its key material, removes the keep from the local
list of active keeps, and finally stops monitoring for any other events
related to that keep.

Notably absent in the current ECDSA client's feature set is any interaction
with the Bitcoin chain. In particular, the ECDSA client does not contain any
functionality for connecting to a Bitcoin node, nor does it at any point
assemble Bitcoin data.

== Proposal

=== Goal

This proposal is focused on achieveing a "least effort" implementation of a
recovery protocol that can handle happy paths for BTC distribution. Where
relevant, it points out _unhappy_ paths and may outline how they might be
dealt with in the future, but these unhappy paths are explicitly considered
out of scope for this RFC.

Additionally, this proposal avoids _strictly requiring_ a connection to a
Bitcoin node, as that is an additional piece of infrastructure that triggers
additional requirements for larger staking providers that may be operating
many nodes on behalf of multiple stakers.

=== Implementation

It is important to observe that interaction with the Bitcoin chain is
_strictly unnecessary_ to construct and sign a Bitcoin transaction that
transmits the BTC held by a keep to n addresses, split evenly.

==== Bitcoin Transaction Requirements

The specific goal to recover BTC from a terminated keep is an N-way split of
the BTC, ~1/N going to each of the N signers in the signing group. To do this, a
Bitcoin transaction can be constructed with a single input (the UTXO that funded
the tBTC deposit) and N outputs (one for each signer). A fee, F, is subtracted
from the deposit's lot size, L, and (L-F)/N BTC is sent to each signer.

To compute the per-signer amount, the client needs to know:

- N, the number of signers in the group.
- F, the desired fee.
- L, the deposit lot size.

Once the amount is known, the Bitcoin sighash must be computed in order to
construct a transaction that can spend the tBTC deposit's UTXO; see the tBTC
spec's section on https://docs.keep.network/tbtc/#sighash[Standardized
Sighash Construction] for an introduction to this process. Computing the sighash
requires two additional pieces of data:

- The previous outpoint, which is the concatenation of the funding UTXO's
  32-byte little-endian transaction hash followed by the 4-byte little-endian
  index of the output pointing to the funding UTXO.
- The previous output script, which is to say the address of the deposit.

Notably, both of these pieces of data can be retrieved or computed solely
from data available on the tBTC deposit contract (the previous outpoint
cannot be retrieved solely from the ECDSA keep contract, but requires the
associated tBTC deposit contract).

Finally, once the per-signer amount and sighash are both known, constructing the
signed Bitcoin transaction requires a few more pieces of information:

- The signature of the sighash, which must be generated via the threshold ECDSA
  functionality of the keep.
- The public key of the current holder, which in this case is the keep and
  should be computable locally by each signer.
- For each of the signers, a Bitcoin address to receive the split amount.

==== Required Inputs

From this, we reach the full set of required inputs and where they can be
procured or computed:

- N, the number of signers in the group, available on the Keep contract
  from the `getMembers` view method, but also tracked locally on the client
  alongside the members of the keep.
- L, the deposit lot size, available on the tBTC deposit contract from the
  `lotSizeSatoshis` view method.
- The previous outpoint describing the deposit UTXO, available on the tBTC
  deposit contract from the `fundingInfo` view method, which returns it as
  the third `utxoOutpoint` entry in its 3-part return tuple.
- The keep's public key, available on the Keep contract from the
  `getPublicKey` view method.
- The deposit redemption script, straightforwardly computable from the keep's
  public key in a way detailed in the section on <<output-script>>.
- One Bitcoin address per signer, specified on the client in a way detailed
  in the section on <<recovery-address>>.
- The keep's signature on the sighash produced by the previous items,
  computed via the threshold ECDSA protocol in a way detailed in the section on
  <<signing>>.
- F, the desired fee, which is a function of the going feerate on the Bitcoin
  network and the number of bytes in the final transaction.

The desired fee is the most problematic one to procure under the goal of not
strictly requiring a Bitcoin node connection, as generally a Bitcoin node
provides estimates of the feerates that will achieve transaction confirmation
within a certain amount of time. A short-term solution is proposed in the
section on <<bitcoin-fee>>.

[[output-script]]
===== Computing the Deposit Output Script

[[recovery-address]]
===== Specifying an Operator's Bitcoin Recovery Address

To specify a given operator's Bitcoin Recovery Address, this proposal
suggests adding a single key to the `Extensions.TBTC.BTCRefunds` config
entry, `BeneficiaryAddress`. The value for this key should be one of:

- A simple BTC address.
- An xpub, ypub, or zpub that allows the client to derive new addresses for
  each refund.

The challenge with a *pub is that, to avoid reuse, it needs to do one of two
things:

- Be able to check, on-chain, whether a given address has been used; or,
- Have a *pub that is only meant for use by the client, and have the client
  track the latest address generated (as an index starting at 0).

To avoid _strictly requiring_ a connection to a Bitcoin node, this RFC
proposes tracking the latest address generated, and allowing an additional
config key, `TargetDerivationStartIndex`, that sets a starting point for such
derivations. The client should write the updated index to the `current/`
directory that tracks active key shares, to an encrypted file named
`current-btc-refund-derivation-index`. The operator should then seek to
obtain from the staker an extended public key that is only used for this
purpose.

If an optional Bitcoin node connection is available (see <<electrs>>), the
client should additionally check a derived address for a balance before
publishing. A fallback could be implemented that checks
`https://blockstream.info/api/address/<address>` for a given derived address
to ensure `tx_count` is 0.

[[bitcoin-fee]]
===== Dealing with the Bitcoin Fee

The Bitcoin fee used for clients is something all three signers must agree
on, since it is part of the sighash. To agree on a fee, this proposal
suggests adding a single key to the `Extensions.TBTC.BTCRefunds` config
entry, `MaxFeePerVByte`, which is a value in sats per vByte that represents
the maximum fee per vByte this client is willing to pay in refund
transactions. The default for this value should be 75 sats per vByte.

In addition to this configuration-based max fee, if an optional Bitcoin
connection is available (see <<electrs>>), the client should look up the
25-block suggested fee per vByte and, if it is available and nonzero, should
replace the hardcoded max fee with this value. 25 blocks means confirmation
within ~4 hours. The default of 75 sats per vByte is aimed to be slightly
higher than a reasonable value for 25 blocks, though of course fee market
fluctuation can change this at a moment's notice. The 25-block suggested fee
per vByte should be available at the `/fee-estimates` endpoint of the REST
API, which returns a JSON object with the key `"25"` corresponding to this
fee.

Once each client has its max fee, it will enter the <<signing>> protocol.
This protocol involves exchanging the max fees of all clients and choosing
the lowest max fee acceptable to all clients, and using that as the fee for
the final transaction.

[[signing]]
===== Signing 

// Round 1: exchange addresses and max fees. Reminder that underlying transport
//          ensures the messages are from the correct peers.
// Generate sighash;
// https://github.com/summa-tx/bitcoin-spv/blob/v2.0.0/contracts/CheckBitcoinSigs.sol#L137-L159
// for one-input-one-output in Solidity,
// https://github.com/keep-network/tbtc.js/blob/b91560f579cb41e414fba3a80678bf61659e3061/bin/commands/bitcoin.js#L142-L208 for variable-output in JavaScript.
// Signing via tss
// Signing starts `blockConfirmations` after a termination event is seen.
//
// A keep should not be considered archived until its refund has been handled or
// times out. Timeout for refund handling TBD, but could be extended (e.g.,
// 48-72 hours, or even 1 week) with backoffs or similar. On restart, a keep
// that is in `current` but seen as `terminated` should attempt to go through
// its refund handling. Optionally, it could check a Bitcoin node or the
// Blockstream API for 

==== Submitting the Signed Transaction

// Log signed transaction on WARN level. If an optional Bitcoin node connection
// is present, the client should submit the transaction, even if other clients
// also submit it. Possible default fallback if no Bitcoin node available:
// attempt to POST signed transaction hex to `https://blockstream.info/api/tx`.

=== Limitations

Bitcoin fees, additional dependencies, transaction submission.

== Open Questions

Why not invert this? A single loop monitoring for each of these
events and checking against locally handled keeps.

[[electrs]]
[appendix]
== Optional Electrs REST API Server

The proposal <<Goal>> section proposes avoiding a strict requirement for a
Bitcoin node; however, several parts of the proposal feature an optional
dependency on an Electrs REST API server. This server should be expected to
adhere to the
https://github.com/Blockstream/esplora/blob/master/API.md[Blockstream electrs
REST API], currently implemented by the
https://github.com/Blockstream/electrs/[Blockstream fork of electrs]. This fork
is open source and has a Docker image available; it must be connected to a
bitcoind instance.

To configure this, the `Extensions.TBTC.ElectrsURL` key can be set to the
appropriate URL. This configuration option defaults to
`https://blockstream.info/api/`, but can be explicitly set to a blank string to
disable integration altogether.

[bibliography]
== Related Links

- https://docs.keep.network/tbtc/[tBTC specification]
- https://github.com/Blockstream/esplora/blob/master/API.md[Blockstream API docs]
